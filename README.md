###**第四章**
####**1.	请证明教材中KMP数组（优化和非优化两种）算法正确性。**
采用数学归纳法：
1) 对于next[0] = -1 ，由于是直接进行赋值，由next数组的定义，第一个字符不匹配应该
向右移动i-next[i] = 1 位， 显然对i = 0 是正确的。
2) 假设next数组的前i个值均已经正确获得，现证明得到next[i] 的算法是正确的。
对已经求得的next[i - 1] = k，
若P[i] = P[k] ,
则对于已经得到证明的 P0P1…Pk-1 = Pi-k…Pi-1
现在有 P0P1…Pk-1Pk = Pi-k…Pi-1Pi
因此有next[i] = k+1
若P[i] != P[k]
则next[i] 显然无法达到 k+1，此时应该递归将 k 赋值为 next[k]
由于next数组之前的正确性已得到证明，此时若有P[i] = P[k]，就回到了上一种
况。否则继续递归，直到有p[i] = p[k]，或递归至k = -1 ，此时说明 P0…Pi 不存在前
缀子串与后缀子串相等。此时有next[i] = 0，直接将字符串不匹配的这一位与模式串首
位重新开始匹配。

对于优化过的KMP：
```C
/*增加的代码*/
if(P[i]==P[k])
    next[i] = next[k];
```
在字符串匹配过程中，在访问next[i] 时，是因为字符串此时的位置与模式串Pi位不匹配，对于原算法，令next[i] = k ， 则匹配的下一步就是比较P[k] 与当前位，若有P[i]==P[k]，那么显然比较将会失败。优化避免了此多余比较。
 
####**2.	电话的号码盘一般可以用于输入字母。如用2可以输入A、B、C，3可以输入D、E、F等。对于号码5869872，可以一次输出其代表的所有字母组合。如：JTMWTPA、JTMWTPB..**
####**a)	您是否可以根据这样的一个对应关系设计一个方案，尽可能快地从这些字母组合中找到一个有意义的单词来表述一个电话号码？如：可以用单词computer来描述号码26678837**
可以考虑使用Trie树：
![Trie树示意图][1]
Trie树通过记录字符串的公共前缀达到快速搜索的效果，每个节点有isWord属性记录是否成单词，如图所示的橙色节点。
#####1. 首先遍历词典，插入词汇，建立Trie树：
```C
void insert(Node *root, const char *Word) {
	if (root == NULL || *Word == '\0')
		return;
	Node *parent = root;
	while (*Word != '\0') {
		if (parent->next[*Word - 'a'] == NULL) {
			Node *temp = (Node*)malloc(sizeof(Node));
			for (int i = 0; i<MAX; i++)
				temp->next[i] = NULL;
			temp->isWord = false;
			parent->next[*Word - 'a'] = temp;
			parent = parent->next[*Word - 'a'];
		}
		else
			parent = parent->next[*Word - 'a'];
		Word++;
	}
	p->isWord = true;             
}
```
#####2. 对于已有的字母组合依次在Trie树中查找，看其是否有单词：
```C
bool search(Node *root, const char* number) { 
	Node *p = root;
	while (p != NULL && *number != '\0') {
		p = p->next[*Word - 'a'];
		number++;
	}
	return (p != NULL && p->isWord == true);      
}
```
时空复杂度分析：
建树(插入)的时间复杂度为O（N），N为词典中的单词数量。
查询时间复杂度为O（N），N为已有的号码对应的各种字符串数。
空间复杂度为O(26^n),n为词数，因为是字母Trie树所以是26。

####**b)	对于一个电话号码，是否可以用一个单词来代表呢？怎样才是最快的方法呢？显然，肯定不是所有的电话号码都能够对应到单词上去。**
将词典中所有的单词转化为对应的电话号码插入到一颗红黑树上，号码作为Key，单词作为Value(Value会重复不影响因为只要找到一个单词即可)，类似于STL中的Map。然后对每次Query的电话号码做一次查询即可。

时空复杂度分析：
插入建树时间复杂度为O（LogN），N为词典中的单词数量。
查询的时间复杂度为O（LogN），N为查询的号码个数。
空间复杂度为O(N);
###**第五章 二叉树**
####**1.	证明：由二叉树的中序遍历序列和后序遍历序列可唯一地确定出该二叉树。**
1.若中序遍历和后序遍历是一样，只有1个字符，那么这个字符就是root。
2.字符数大于1。那么先找到后序遍历的最后一个节点。把它设为root。再从中序遍历找到root，则root左边序列在root的左子树，root右边的在其右子树。
不妨设root的左边有lengthLeft长度，右边有lengthRight长度。那么lengthLeft = length – lengthRight - 1。就是说左子树的根节点就是后序遍历从后往前边数的第lengthRight + 2（跨过lengthRight + 1）个。那么这么递归的寻找下去，每个树的左子树和右子树都是可以确定的。这样就可以唯一的确定一颗二叉树。
该方法的关键就在于，后序每次可以找到根，中序可以根据根分出左右子树，递归下去一定唯一确定。类似的前序与中序也可以。![示意中序][2]
####**2.	在一棵表示有序集S的二叉搜索树(binary search tree)中,任意一条从根到叶结点的路径将S分为3部分：在该路径左边结点中的元素组成的集合Sl；在该路径上的结点中的元素组成的集合S2；在该路径右边结点中的元素组成的集合S3。S=S1∪S2∪S3。若对于任意的a∈Sl,b∈S2，c∈S3是否总有a≤b≤c?为什么?**
举下面的反例：标记*的为选取得路径
```
							  *46
							/    \
                          *20	   50
                        /   \     /   \
					  15   *30	 47	   60
		        		   /  \
				          *25  40		
```
那么S1 ={15}
S2 = {20，25，30，46}
S3 = {40，45，50，60
然而S3中的40 < 46，而46在S2中。故不是总有a<=b<=c的。

####**3.	一种表示二维数组的方法是4叉树表示法，其中一个结点的4个儿子分别表示数组的NE,SE,SW,NW。四个分块如图所示。这种表示二维数组的4叉树称为金字塔。**
####**a)	设计一个基于金字塔表示法的矩阵乘法算法**
递归计算，为了防止因为自己的值改变而影响后面的计算，所以将新生成的结果放到新的树里面。每次递归先生成新结点，然后做乘法和加法、
结束出口：每一个子节点都是0则结束递归。为空则视为0。
T->NW=(t1->NW * t2->NW)+(t1->NE * t2->SW));
T->NE=(t1->NW * t2->NE)+(t1->NE * t2->SE));
T->SW=(t1->SW * t2->NW)+(t1->SE * t2->SW));
T->SE=(t1->SW * t2->NE)+(t1->SE * t2->SW));
####**b)	对于给定的2p×2p矩阵，设计一个用二叉树表示这个矩阵的算法。并将这个算法推广到可表示任意M×N矩阵的情形，算法效率如何？**
根结点指向整个矩阵，其中：
奇数层的子结点指向W和E，left_child=*W; right_child=*E;
偶数层的子结点指向N和S，left_child=N*; right_child=S*;
如:T->NW=T->left_child->left_child
然后可以使用a)中的乘法递归计算即可。

####**4.如何使用优先级队列的堆实现解决下列问题？如果输入的数据是有序的，那么又该如何解决？**
####**a)	构建Huffman码；**
可以采用优先队列来建Huffman树从而得到Huffman码。
可以使用一个存放节点指针的优先队列，小端优先，该队列按照指针指向节点的权值来进行排序。
首先根据权值依次建立节点并插入优先队列。
之后，两次取出队列顶，得到当前权值最小的两个节点，将他们的Parent设置为一个新的节点，该节点的权值为两个节点权值的和，然后再将该节点插入优先队列。
依次，队列中的节点将不断减少，直到剩余两个元素，将他们取出按照上一步合并，便得到了整颗Huffman树，遍历可得Huffman码。
如果是有序的可以用优先队列，也可以考虑每次合并节点后将新的节点通过2分查找插入到原有的有序的数组中，这样只要O（NlogN）的复杂度就可以一次到位完成建树
####**b)	计算大型浮点数集合的和；**
简单的做求和可能有精度损失，所以先将所有的浮点数放进一个小端的优先队列，然后每次取出队首的(最小值)进行累加，这样可以保证精度。
输入是有序的则按照从小到大的顺序进行累加即可。
####**c)	在存有10亿个数的文件中找出最大的100万个数；**
先建立一个有100万元素的优先队列。
先插入100万个数，队列首为最小元。后续每读一个数就跟队列首元素比较，若小于堆顶元，就什么也不做；若大于队列首，则插入。
数据是有序的则直接选择最大的100万个数即可。
####**d)	将多个较小的有序文件归并为一个较大的有序文件。**
可以用堆表示每个文件的下一个元素，从而实现堆有序文件的归并。迭代步骤从堆中选出最小的元素，并将其后继插入堆中。n个文件中下一个待输出的元素可以在O（logN）时间内选出。
如果文件本身是有序的，则直接归并即可。

  
###**第六章 树**
####**1.由于化学中同分异构体计数的问题和社会学中族谱研究问题的需要，对无序树（无根树）的计数研究十分丰富。Cayley提出，由n个不同的顶点组成的不同的树的个数为T_n=n^(n-2)。历史上，该式的证明方法从繁复到简单经历了十分漫长的历程。下面我们来看1918年数学家Prufer提出的一种方法。现在，请你说明如何从一个6元序列S恢复一个8阶树，并说明该恢复结果是唯一的。只要把这个结果一般化，你就完成了这个公式的证明。**

例子中的序列为2,4,1,2,4,4。
总共有n个节点,序列中有n-2个值，所以原来的树有8个序号，为1,2,3,4,5,6,7,8。
现在最后加入n，得到序列2,4,1,2,4,4,8
取不在集合{ }中，且不在序列{2,4,1,2,4,4}中的最小值——3，在3与序列第一个数——2，是邻接点，在序列中删除2得到4,1,2,4,4。
再在剩下的数中选取不在集合{3}，且不在序列{4,1,2,4,4,8}中的最小值——5，则5与4是邻接点，删除4。
再在剩下的数中选取不在集合{5,3}，且不在序列{1,2,4,4,8}中的最小值——6，则6与1是邻接点，删除1。
再在剩下的数中选取不在集合{5,3,6}，且不在序列{2,4,4,8}中的最小值——1，则1与2是邻接点，删除2。
再在剩下的数中选取不在集合{5,3,6,1}，且不在序列{4,4,8}中的最小值——2，则2与4是邻接点，删除4。
再在剩下的数中选取不在集合{5,3,6,1,2}，且不在序列{4,8}中的最小值——7，则7与4是邻接点，删除4。
再在剩下的数中选取不在集合{5,3,6,1,2,7}，且不在序列{8}中的最小值——4，则4与8是邻接点，删除8。
完毕

通用叙述：
prufer编码为(A1,A2,A3,A4,A5,.....An-2)，加入n得到序列Seq（A1,A2,A3,A4,A5,.....An-2，n）
while (!seq.empty()) {
    设一个集合Set{}初始为空，每次选在一个不在Seq中且不在Set中的Min，则Min与Seq[0]邻接
在Set中添加Min，删除Seq[0]
}
即可建立整个树。


####**2.设T 是一棵带权树，树的每一条边带一个正权。又设S 是T 的顶点集,T/S 是从树T 中将S中顶点删去后得到的森林。如果T/S中所有树的从根到叶的路长都不超过d ，则称T/S是一个d 森林。**
####**a)	设计一个算法求T的一个最小顶点集S，使T/S是d 森林。**
1.用父亲数组parent存父节点；leaf存储叶结点，层次遍历输入数据   
2.从叶子结点向根结点移动，从根结点的路长超过d时（如果未找到，或找到的是已删除点，则继续下一个），将所找到的结点在leaf表中设为已删除，并将其放入已删除结点列表中，其上一结点设为叶结点，下一结点的父节点设为空。直到leaf读完
####**b)	简要分析你所设计算法的正确性和时间复杂度。**
b)这样的算法可以保证每一个叶结点从叶到根不超过d;
另外，由于是层次遍历存储，且读数时从后向前，可以做到，先满足最长的，所以得到的应该是最少的。
算法复杂度O(logN);
####**c)	对下图所表示的树T，给出当d=2时，你在(1)中设计的算法运行得到的最小顶点集S。**
S = { B };

  [1]: http://powman.org/wp-content/uploads/2013/08/trie.png
  [2]: https://mail.google.com/mail/u/0/?ui=2&ik=0922108e84&view=fimg&th=14974efa47057c2c&attid=0.0.1&disp=emb&realattid=ii_i21m2lq41_14974eef847c1802&attbid=ANGjdJ-r1Ztv6HUo5w4BZxyx3R9vULGefV6a1d03dhg9MDZIPVrheVMr8lRQ61G3PQ1rGfrwzfKTNfocrpb8MqFO-8M0vFD-Gpw2aLBsDd2iR5YCnbbWJC004O-pCbw&sz=w1600-h1000&ats=1415023703996&rm=14974efa47057c2c&zw&atsh=1
